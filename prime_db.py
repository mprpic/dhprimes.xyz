import re
import os
import sys
import sqlite3
import argparse
from peewee import *
from pyasn1.codec.der import decoder
from base64 import b64decode

db = SqliteDatabase('dhprimes.db')

class Primes(Model):
    integer = TextField()
    generator = TextField()
    bitsize = IntegerField()
    base16 = TextField()
    pem = TextField()
    b64der = TextField()
    full = TextField()

    class Meta:
        database = db

def create_table():
    db.create_table(Primes)

def parse_gnutls_file(text, f):
    # Check validity of all attributes in a GnuTLS-generated DH param file
    # since we store it in its entirety.
    regexes = [
        (r'generator:(.*?)prime:', 'base 16 generator'),
        (r'prime:(.*?)-----BEGIN', 'base 16 prime number'),
        (r'(-{5}BEGIN DH PARAMETERS.*?END DH PARAMETERS-{5})', 'DH parameters'),
    ]

    raw_data = []
    for i, (regex, name) in enumerate(regexes):
        search = re.search(regex, text, re.DOTALL)
        if search:
            raw_data.append(search.group(1))
        else:
            print('ERROR: Could not find {} in {}; skipping'.format(name, f))
            return

    params = {}
    params['generator'] = int(re.sub(r'\s', r'', raw_data[0]).replace(':', ''), 16)
    params['pem'] = raw_data[2]
    params['b64der'] = re.search(r'-{5}BEGIN DH PARAMETERS-{5}\n(.*)\n-{5}END DH PARAMETERS-{5}', \
                                 raw_data[2], re.DOTALL).group(1).replace('\n', '')
    params['base16'] = re.sub(r'\s', r'', raw_data[1]).rstrip(':')
    params['full'] = text
    try:
        params['integer'] = int(params['base16'].replace(':', ''), 16)
    except ValueError:
        print('ERROR: Malformed base 16 prime in {}; skipping'.format(f))
        return
    params['bitsize'] = len(bin(params['integer'])[2:])

    # Check PEM cert and compare with data above
    seq, _ = decoder.decode(b64decode(params['b64der']))
    if not int(seq.getComponentByPosition(0)) == params['integer']:
        print('ERROR: PEM integer does not match base16 integer in {}; skipping'.format(f))
        return
    if not int(seq.getComponentByPosition(1)) == params['generator']:
        print('ERROR: PEM generator does not match base16 generator in {}; skipping'.format(f))
        return

    return params

def parse_openssl_file(text, f):
    # Check validity of all attributes in an OpenSSL-generated DH param
    # file since we store it in its entirety.
    regexes = [
        (r'\((\d+) bit\)', 'bit size'),
        (r'generator: (\d+) \(', 'generator'),
        (r'prime:(.*?)generator', 'base 16 prime number'),
        (r'(-{5}BEGIN DH PARAMETERS.*?END DH PARAMETERS-{5})', 'DH parameters'),
    ]

    raw_data = []
    for i, (regex, name) in enumerate(regexes):
        search = re.search(regex, text, re.DOTALL)
        if search:
            raw_data.append(search.group(1))
        else:
            print('ERROR: Could not find {} in {}; skipping'.format(name, f))
            return

    params = {}
    params['bitsize'] = int(raw_data[0])
    params['generator'] = int(raw_data[1])
    params['pem'] = raw_data[3]
    params['b64der'] = re.search(r'-{5}BEGIN DH PARAMETERS-{5}\n(.*)\n-{5}END DH PARAMETERS-{5}', \
                                 raw_data[3], re.DOTALL).group(1).replace('\n', '')
    params['base16'] = re.sub(r'\s', r'', raw_data[2])
    params['full'] = text
    try:
        params['integer'] = int(params['base16'].replace(':', ''), 16)
    except ValueError:
        print('ERROR: Malformed base 16 prime in {}; skipping'.format(f))
        return

    # Check bit size matches int size
    if not int(params['bitsize']) == len(bin(params['integer'])[2:]):
        print('ERROR: Bit size does not match integer size in {}; skipping'.format(f))
        return

    # Check PEM cert and compare with data above
    seq, _ = decoder.decode(b64decode(params['b64der']))
    if not int(seq.getComponentByPosition(0)) == params['integer']:
        print('ERROR: PEM integer does not match base16 integer in {}; skipping'.format(f))
        return
    if not int(seq.getComponentByPosition(1)) == params['generator']:
        print('ERROR: PEM generator does not match base16 generator in {}; skipping'.format(f))
        return

    return params

def parse_file(f):
    text = open(f).read()

    if 'DH Parameters' in text and 'BEGIN DH PARAMETERS' in text:
        return parse_openssl_file(text, f)
    elif 'Recommended key length' in text and 'BEGIN DH PARAMETERS' in text:
        return parse_gnutls_file(text, f)
    else:
        return

def main():

    p = argparse.ArgumentParser(description='Create/Update SQLite database \
                                             with DH primes generated by OpenSSL.')
    p.add_argument('-i', '--input', dest='in_files',
                 action='store', help='File or directory with DH prime(s)')
    p.add_argument('-o', '--out_db', dest='out_db',
                 action='store', help='Output to database file (default is dhprimes.db)')
    p.add_argument('-p', '--print', dest='print_output',
                 action='store_true', help='Print output instead of creating database')
    args = p.parse_args()

    if not args.in_files:
        p.error('You must specify input file or directory')

    if not os.path.exists(args.in_files):
        p.error('Specified file or directory does not exist')

    all_files = []
    if os.path.isdir(args.in_files):
        for directory, _, files in os.walk(args.in_files):
            if not '.git' in directory:
                all_files.extend([ os.path.join(directory, x) for x in files ])
    elif os.path.isfile(args.in_files):
        files.append(args.in_files)
    else:
        p.error('Specified input is not a file or a directory')

    if not Primes.table_exists():
        create_table()

    # Bulk updates of the database to keep memory usage low. Also Peewee
    # can't handle more than 100 of these updates in insert_many.
    for idx in range(0, len(all_files), 100):
        updates = []
        for f in all_files[idx:idx+100]:
            params = parse_file(f)
            if params:
                updates.append(params)
        if updates:
            with db.atomic():
                Primes.insert_many(updates).execute()

if __name__ == '__main__':
    main()
